// 思路：
// 1. 找一个基数 n ，将序列大于 n 的数放到 n 的右边，反之放到左边
// 2. 用两个变量 i j ，分别从右往左找到一个小于 n 和 从左往右找到大于 n 的数，调换双方位置，直到 i j 碰头为止
// 3. 左右的序列一样用此方法排序，直到结束

// 优点：
// 1. 快排的每次交换都是跳跃式的，不会像冒泡只会在相邻数之间交换，总的交换速度就少了
// 2. 最坏去情况只可能是相邻的两个数的交换O(n²)，评价时间复杂度是(NlogN)

// 适用场景：
// 1. 任何场景

const numList: number[] = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

function quicksort() {

}